<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="Keywords" content="">
<meta name="Description" content="">
<title>Document</title>
<style type="text/css">
	* {margin:0;padding:0;}
	body{font-size:12px;font-family:"微软雅黑";}
	ul,li{list-style:none;}
	a{text-decoration:none;}
	img{vertical-align:top;}
</style>
</head>
<body>

	<script type="text/javascript">
		/*
			类式（原型链）继承的原理：子类的原型指向父类创建出来的对象（对象复制了父类的函数与属性；并且拥有父类原型的函数与属性）；从而使得子类的对象按照原型链去继承了父类的属性和方法
			缺点：1.由于是类式继承是通过原型继承的，所以一个子类对象只要改变了引用类型的值，其他子类在调用这个引用类型时也会发生改变；2.并且不能够传参继承
			注意：instanceof是根据原型链来判断对象是某个类的实例！！！
		*/
		function SuperClass(){
			this.books = ["js","css","java"];
		};
		function SubClass(){};
		//子类的原型指向父类的实例（对象）
		SubClass.prototype = new SuperClass();
		//改变原型的构造器
		SubClass.prototype.constructor = SubClass;
		/*//子类的对象创建
		var instance = new SubClass();
		//instance是属于SubClass的实例
		alert(instance instanceof SubClass);//true
		//同样由于子类的原型指向了父类的实例，从而导致子类对象继承了父类；固instance属于SuperClass的实例
		alert(instance instanceof SuperClass);//true
		//由于instanceof比较的是对象是否属于类的实例，所以不关构造函数的事！！！
		alert(SubClass instanceof SuperClass);//false
		//因为子类的原型被赋值了子类的对象；而子类对象又是由父类创建出来，所以子类的原型属于父类的实例，而不是属于子类的实例！！！
		alert(SubClass.prototype instanceof SubClass);//false
		//由于子类原型指向父类对象，所以是父类的实例
		alert(SubClass.prototype instanceof SuperClass);//true
		//Object是所有类或对象的父类，都可以默认被继承！！！
		alert(instance instanceof Object);//true*/
		var instance1 = new SubClass();
		var instance2 = new SubClass();
		alert(instance1.books);
		instance1.books.push("jquery");
		alert(instance1.books);
		//类式继承改变了引用类型的值（就是放在一个地址内存里的共享值）
		alert(instance2.books);
		//由于原型指向了父类的实例，所以构造器属于父类
		alert(instance2.constructor);
	</script>
</body>
</html>
